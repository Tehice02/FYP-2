"""
Feature Extraction Module
Extracts 34 NetFlow-style features from network flow records
Matches the feature set used in UNSW-NB15 dataset
"""

import numpy as np
from collections import defaultdict
from utils.config import Config
from utils.logger import log_error


class FeatureExtractor:
    """Extract 34 features from network flow for ML prediction"""
    
    @staticmethod
    def extract_features(flow_record):
        """
        Extract 34 features from FlowRecord
        
        Args:
            flow_record: FlowRecord object containing packet information
            
        Returns:
            Numpy array of shape (1, 34) with extracted features
        """
        try:
            features = {}
            
            # 1. Duration (seconds)
            features['dur'] = flow_record.duration
            
            # 2. Protocol (6=TCP, 17=UDP, 1=ICMP, 0=Other)
            features['proto'] = flow_record.protocol_num
            
            # 3. Service (port-based approximation)
            features['service'] = FeatureExtractor._map_port_to_service_num(flow_record.dst_port)
            
            # 4. State (TCP connection state encoded as number)
            features['state'] = FeatureExtractor._encode_tcp_state(flow_record.tcp_state)
            
            # 5. Source packets
            features['spkts'] = flow_record.src_packets
            
            # 6. Destination packets
            features['dpkts'] = flow_record.dst_packets
            
            # 7. Source bytes
            features['sbytes'] = flow_record.src_bytes
            
            # 8. Destination bytes
            features['dbytes'] = flow_record.dst_bytes
            
            # 9. Rate (bytes per second)
            features['rate'] = (features['sbytes'] + features['dbytes']) / max(features['dur'], 0.001)
            
            # 10. Source TTL
            features['sttl'] = flow_record.src_ttl_avg
            
            # 11. Destination TTL
            features['dttl'] = flow_record.dst_ttl_avg
            
            # 12. Source load (bytes per second)
            features['sload'] = features['sbytes'] / max(features['dur'], 0.001)
            
            # 13. Destination load (bytes per second)
            features['dload'] = features['dbytes'] / max(features['dur'], 0.001)
            
            # 14. Source packet loss
            features['sloss'] = flow_record.src_packet_loss
            
            # 15. Destination packet loss
            features['dloss'] = flow_record.dst_packet_loss
            
            # 16. Source inter-packet time (mean)
            features['sintpkt'] = flow_record.src_inter_packet_time
            
            # 17. Destination inter-packet time (mean)
            features['dintpkt'] = flow_record.dst_inter_packet_time
            
            # 18. Source jitter (variance in inter-packet time)
            features['sjit'] = flow_record.src_jitter
            
            # 19. Destination jitter
            features['djit'] = flow_record.dst_jitter
            
            # 20. Source window size (average)
            features['swin'] = flow_record.src_window_size
            
            # 21. Destination window size (average)
            features['dwin'] = flow_record.dst_window_size
            
            # 22. Source TCP base sequence number
            features['stcpb'] = flow_record.src_tcp_base_seq
            
            # 23. Destination TCP base sequence number
            features['dtcpb'] = flow_record.dst_tcp_base_seq
            
            # 24. TCP round trip time
            features['tcprtt'] = flow_record.tcp_rtt
            
            # 25. SYN-ACK time
            features['synack'] = flow_record.syn_ack_time
            
            # 26. ACK-DATA time
            features['ackdat'] = flow_record.ack_data_time
            
            # 27. Source mean packet size
            features['smean'] = features['sbytes'] / max(features['spkts'], 1)
            
            # 28. Destination mean packet size
            features['dmean'] = features['dbytes'] / max(features['dpkts'], 1)
            
            # 29. Transaction depth (HTTP-related, 0 if not HTTP)
            features['trans_depth'] = 0
            
            # 30. Response body length (HTTP-related, 0 if not HTTP)
            features['response_body_len'] = 0
            
            # 31. Connection count to same service from same source
            features['ct_srv_src'] = flow_record.ct_srv_src
            
            # 32. Connection count with same state and TTL
            features['ct_state_ttl'] = flow_record.ct_state_ttl
            
            # 33. Connection count to destination in last time window
            features['ct_dst_ltm'] = flow_record.ct_dst_ltm
            
            # 34. Connection count from source to dest port in last time window
            features['ct_src_dport_ltm'] = flow_record.ct_src_dport_ltm
            
            # Convert to numpy array in correct order
            feature_vector = np.array([features[f] for f in Config.FEATURE_NAMES]).reshape(1, -1)
            
            # Validate and clean
            feature_vector = np.nan_to_num(feature_vector, nan=0.0, posinf=999999.0, neginf=-999999.0)
            
            return feature_vector
            
        except Exception as e:
            log_error(f"Feature extraction failed: {str(e)}", component='FeatureExtractor')
            # Return zero vector as fallback
            return np.zeros((1, Config.NUM_FEATURES))
    
    @staticmethod
    def _map_port_to_service_num(port):
        """Map port to service number (simplified)"""
        service_map = {
            20: 1, 21: 1,      # FTP
            22: 2,             # SSH
            23: 3,             # Telnet
            25: 4,             # SMTP
            53: 5,             # DNS
            80: 6,             # HTTP
            110: 7,            # POP3
            143: 8,            # IMAP
            443: 9,            # HTTPS
            445: 10,           # SMB
            3306: 11,          # MySQL
            3389: 12,          # RDP
            5432: 13,          # PostgreSQL
            8080: 14,          # HTTP-Alt
        }
        return service_map.get(port, 0)
    
    @staticmethod
    def _encode_tcp_state(state):
        """Encode TCP state as number"""
        state_map = {
            'FIN': 1, 'SYN': 2, 'RST': 3, 'PSH': 4,
            'ACK': 5, 'URG': 6, 'ECE': 7, 'CWR': 8,
            'FIN_WAIT': 9, 'SYN_SENT': 10, 'SYN_RECV': 11,
            'ESTABLISHED': 12, 'CLOSE_WAIT': 13, 'LAST_ACK': 14,
            'TIME_WAIT': 15, 'CLOSED': 16
        }
        return state_map.get(state, 0)


class FlowRecord:
    """
    Represents a network flow with all necessary statistics
    Used to aggregate packets and calculate features
    """
    
    def __init__(self, flow_key):
        """
        Initialize flow record
        
        Args:
            flow_key: Tuple of (src_ip, dst_ip, src_port, dst_port, protocol)
        """
        self.flow_key = flow_key
        self.src_ip = flow_key[0]
        self.dst_ip = flow_key[1]
        self.src_port = flow_key[2]
        self.dst_port = flow_key[3]
        self.protocol = flow_key[4]
        
        # Timing
        self.start_time = None
        self.last_packet_time = None
        self.duration = 0
        
        # Packet counts
        self.src_packets = 0
        self.dst_packets = 0
        self.total_packets = 0
        
        # Byte counts
        self.src_bytes = 0
        self.dst_bytes = 0
        
        # TTL statistics
        self.src_ttl_values = []
        self.dst_ttl_values = []
        self.src_ttl_avg = 0
        self.dst_ttl_avg = 0
        
        # Window sizes
        self.src_window_sizes = []
        self.dst_window_sizes = []
        self.src_window_size = 0
        self.dst_window_size = 0
        
        # TCP specific
        self.tcp_state = 'UNKNOWN'
        self.src_tcp_base_seq = 0
        self.dst_tcp_base_seq = 0
        self.tcp_flags = {'SYN': 0, 'ACK': 0, 'FIN': 0, 'RST': 0, 'PSH': 0, 'URG': 0}
        self.syn_time = None
        self.syn_ack_time = 0
        self.ack_time = None
        self.ack_data_time = 0
        self.tcp_rtt = 0
        
        # Inter-packet timing
        self.src_packet_times = []
        self.dst_packet_times = []
        self.src_inter_packet_time = 0
        self.dst_inter_packet_time = 0
        self.src_jitter = 0
        self.dst_jitter = 0
        
        # Loss estimation
        self.src_packet_loss = 0
        self.dst_packet_loss = 0
        
        # Connection tracking features
        self.ct_srv_src = 0
        self.ct_state_ttl = 0
        self.ct_dst_ltm = 0
        self.ct_src_dport_ltm = 0
        
        # Protocol number
        self.protocol_num = self._get_protocol_num()
        
        # Packet list for detailed analysis
        self.packets = []
    
    def _get_protocol_num(self):
        """Convert protocol name to number"""
        protocol_map = {'TCP': 6, 'UDP': 17, 'ICMP': 1}
        return protocol_map.get(self.protocol, 0)
    
    def add_packet(self, packet, direction='forward', timestamp=None):
        """
        Add packet to flow record
        
        Args:
            packet: Packet object (Scapy packet)
            direction: 'forward' or 'backward'
            timestamp: Packet timestamp
        """
        import time
        
        # Store packet
        self.packets.append(packet)
        
        # Update timing
        current_time = timestamp or time.time()
        if self.start_time is None:
            self.start_time = current_time
        self.last_packet_time = current_time
        self.duration = self.last_packet_time - self.start_time
        
        # Update packet counts
        self.total_packets += 1
        packet_size = len(packet)
        
        if direction == 'forward':
            self.src_packets += 1
            self.src_bytes += packet_size
            
            # Track timing for inter-packet time
            self.src_packet_times.append(current_time)
            
            # Extract TTL
            if hasattr(packet, 'ttl'):
                self.src_ttl_values.append(packet.ttl)
            
            # Extract window size (TCP)
            if hasattr(packet, 'window'):
                self.src_window_sizes.append(packet.window)
            
        else:  # backward
            self.dst_packets += 1
            self.dst_bytes += packet_size
            
            # Track timing
            self.dst_packet_times.append(current_time)
            
            # Extract TTL
            if hasattr(packet, 'ttl'):
                self.dst_ttl_values.append(packet.ttl)
            
            # Extract window size (TCP)
            if hasattr(packet, 'window'):
                self.dst_window_sizes.append(packet.window)
        
        # Update TCP-specific features
        self._update_tcp_features(packet, direction, current_time)
        
        # Calculate derived statistics
        self._calculate_statistics()
    
    def _update_tcp_features(self, packet, direction, timestamp):
        """Update TCP-specific features"""
        if not hasattr(packet, 'flags'):
            return
        
        flags = packet.flags if hasattr(packet, 'flags') else 0
        
        # Track TCP flags
        if flags & 0x02:  # SYN
            self.tcp_flags['SYN'] += 1
            if self.syn_time is None:
                self.syn_time = timestamp
        if flags & 0x10:  # ACK
            self.tcp_flags['ACK'] += 1
            if self.ack_time is None and self.syn_time is not None:
                self.ack_time = timestamp
                self.syn_ack_time = self.ack_time - self.syn_time
        if flags & 0x01:  # FIN
            self.tcp_flags['FIN'] += 1
        if flags & 0x04:  # RST
            self.tcp_flags['RST'] += 1
        if flags & 0x08:  # PSH
            self.tcp_flags['PSH'] += 1
        if flags & 0x20:  # URG
            self.tcp_flags['URG'] += 1
        
        # Determine TCP state
        self.tcp_state = self._determine_tcp_state()
        
        # Extract sequence numbers
        if hasattr(packet, 'seq'):
            if direction == 'forward' and self.src_tcp_base_seq == 0:
                self.src_tcp_base_seq = packet.seq
            elif direction == 'backward' and self.dst_tcp_base_seq == 0:
                self.dst_tcp_base_seq = packet.seq
    
    def _determine_tcp_state(self):
        """Determine TCP connection state based on flags"""
        if self.tcp_flags['SYN'] > 0 and self.tcp_flags['ACK'] == 0:
            return 'SYN_SENT'
        elif self.tcp_flags['SYN'] > 0 and self.tcp_flags['ACK'] > 0:
            return 'ESTABLISHED'
        elif self.tcp_flags['FIN'] > 0:
            return 'FIN_WAIT'
        elif self.tcp_flags['RST'] > 0:
            return 'CLOSED'
        else:
            return 'UNKNOWN'
    
    def _calculate_statistics(self):
        """Calculate derived statistics from collected data"""
        # TTL averages
        if self.src_ttl_values:
            self.src_ttl_avg = np.mean(self.src_ttl_values)
        if self.dst_ttl_values:
            self.dst_ttl_avg = np.mean(self.dst_ttl_values)
        
        # Window size averages
        if self.src_window_sizes:
            self.src_window_size = np.mean(self.src_window_sizes)
        if self.dst_window_sizes:
            self.dst_window_size = np.mean(self.dst_window_sizes)
        
        # Inter-packet time and jitter
        if len(self.src_packet_times) > 1:
            inter_times = np.diff(self.src_packet_times)
            self.src_inter_packet_time = np.mean(inter_times)
            self.src_jitter = np.std(inter_times)
        
        if len(self.dst_packet_times) > 1:
            inter_times = np.diff(self.dst_packet_times)
            self.dst_inter_packet_time = np.mean(inter_times)
            self.dst_jitter = np.std(inter_times)
        
        # Estimate RTT (simplified)
        if self.syn_ack_time > 0:
            self.tcp_rtt = self.syn_ack_time
    
    def is_ready_for_prediction(self, timeout=30, max_packets=100):
        """
        Check if flow is ready for prediction
        
        Args:
            timeout: Maximum flow duration before prediction (seconds)
            max_packets: Maximum packets before prediction
            
        Returns:
            Boolean indicating if flow is ready
        """
        if self.start_time is None:
            return False
        
        import time
        current_time = time.time()
        elapsed = current_time - self.start_time
        
        return elapsed >= timeout or self.total_packets >= max_packets
    
    def get_summary(self):
        """Get flow summary for logging"""
        return {
            'src_ip': self.src_ip,
            'dst_ip': self.dst_ip,
            'src_port': self.src_port,
            'dst_port': self.dst_port,
            'protocol': self.protocol,
            'duration': self.duration,
            'packets': self.total_packets,
            'bytes': self.src_bytes + self.dst_bytes
        }
